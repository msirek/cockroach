# =============================================================================
# project.opt contains exploration rules for the Project operator.
# =============================================================================

# EliminateIndexJoinInsideProject discards an IndexJoin operator inside a
# Project operator when the input of the IndexJoin produces all the columns
# required by the Project.
#
# This rule is useful when using partial indexes. When generating partial index
# scans, expressions can be removed from filters because they exactly match
# expressions in partial index predicates and there is no need to apply the
# filter after the scan. Columns referenced in the removed expressions may no
# longer need to be fetched.
#
# Consider the example:
#
#   CREATE TABLE t (i INT, s STRING, INDEX (i) WHERE s = 'foo')
#
#   SELECT i FROM t WHERE s = 'foo'
#
# The normalized expression for the SELECT query is:
#
#   project
#    ├── columns: i:1
#    └── select
#         ├── columns: i:1 s:2!null
#         ├── scan t
#         │    └── columns: i:1 s:2
#         └── filters
#              └── s:2 = 'foo'
#
# GeneratePartialIndexScans will generate this expression:
#
#   project
#    ├── columns: i:1
#    └── index-join t
#         ├── columns: i:1 s:2!null
#         └── scan t@secondary,partial
#              └── columns: i:1 rowid:4!null
#
# The IndexJoin is created because the Select expression in the previous
# expression required s in order to apply the (s = 'foo') filter. However,
# because rows in the partial index are already filtered by (s = 'foo'), column
# s does not need to be fetched. The IndexJoin can be eliminated, resulting in
# the expression:
#
#   project
#    ├── columns: i:1
#    └── scan t@secondary,partial
#         └── columns: i:1 rowid:4!null
#
[EliminateIndexJoinInsideProject, Explore]
(Project
    (IndexJoin $input:*)
    $projections:*
    $passthrough:* &
        (ColsAreSubset
            (UnionCols
                (ProjectionOuterCols $projections)
                $passthrough
            )
            (OutputCols $input)
        )
)
=>
(Project $input $projections $passthrough)

# SplitProjectedDisjunction performs a transformation similar to
# SplitDisjunction, but it uses information from the parent Project operation
# to allow pruning of unnecessary filter columns.
# There is no distinction between accessed columns (e.g. for filter evaluation)
# and projected columns in a ScanExpr.
# They are both lumped together in OutputCols, so unless this
# distinction is added, there is no clean way to handle projection pruning
# without examining the ProjectExpr.
[SplitProjectedDisjunction, Explore]
(Project
    (Select
        $input:(Scan
                $scanPrivate:* & (IsCanonicalScan $scanPrivate)
            ) &
            (HasStrictKey $input)
        $filters:* &
            (Let
                (
                    $leftFilter
                    $rightFilter
                    $itemToReplace
                    $ok
                ):(SplitDisjunction $scanPrivate $filters)
                $ok
            )
    )
    $projections:*
    $passthrough:* &
        (Let
            ($projectCols):(UnionCols
                $passthrough
                (getExpressionColSet $projections)
            )
            $ok
        ) &
        (Let
            ($aggCols):(DifferenceCols
                $projectCols
                (KeyCols $input))
            $ok
        ) &
        ^(ColsAreEmpty $aggCols) &
        (subsetOf $projectCols (OutputCols $input)) &
        (subsetOf (KeyCols $input) $projectCols) &
        (ColsAreStrictKey (IntersectionCols $projectCols (OutputCols $input)) $input)
)
=>
(Project
    $distinctOn:(DistinctOn
        (UnionAll
            $leftProject:(Project
                (Select
                    $leftScan:(Scan (DuplicateScanPrivate $scanPrivate))
                    (MapFilterCols
                        (ReplaceFiltersItem
                            $filters
                            $itemToReplace
                            $leftFilter
                        )
                        $outCols:(OutputCols $input)
                        (OutputCols $leftScan)
                    )
                )
                []
                (remapColSet
                    $projectCols
                    $outCols
                    (OutputCols $leftScan)
                )
            )
            $rightProject:(Project
                (Select
                    $rightScan:(Scan (DuplicateScanPrivate $scanPrivate))
                    (MapFilterCols
                        (ReplaceFiltersItem
                            $filters
                            $itemToReplace
                            $rightFilter
                        )
                        $outCols
                        (OutputCols $rightScan)
                    )
                )
                []
                (remapColSet
                    $projectCols
                    $outCols
                    (OutputCols $rightScan)
                )
            )
            (MakeSetPrivate
                (OutputCols $leftProject)
                (OutputCols $rightProject)
                $projectCols
            )
        )
        (MakeAggCols ConstAgg $aggCols)
        (MakeGrouping (KeyCols $input) (EmptyOrdering))
    )
    $projections
    $projectCols
)

# SplitProjectedDisjunctionAddKey performs a transformation similar to
# SplitDisjunctionAddKey, but it uses information from the parent Project
# operation to allow pruning of unnecessary filter columns.
# There is no distinction between accessed columns (e.g. for filter evaluation)
# and projected columns in a ScanExpr. They are both lumped together in
# OutputCols, so unless this distinction is added, there is no clean way to
# handle pruning of projected-away columns from a ScanExpr without examining the
# ProjectExpr.
# This rule handles both the HasStrictKey and ^HasStrictKey cases because
# projection pruning may remove some strict key columns, making the HasStrictKey
# approach invalid due to lack of all required grouping columns.
[SplitProjectedDisjunctionAddKey, Explore]
(Project
    (Select
        $input:(Scan
                $scanPrivate:* & (IsCanonicalScan $scanPrivate)
            ) &
            ^(HasStrictKey $input)
        $filters:* &
            (Let
                (
                    $leftFilter
                    $rightFilter
                    $itemToReplace
                    $ok
                ):(SplitDisjunction $scanPrivate $filters)
                $ok
            )
    )
    $projections:*
    $passthrough:* &
        (Let
            ($scanCols):(UnionCols3
                $passthrough
                (getExpressionColSet $projections)
                (PrimaryKeyCols
                    (TableIDFromScanPrivate $scanPrivate)
                )
            )
            $ok
        )
)
=>
(Project
    (Union
        $leftProject:(Project
            (Select
                $leftScan:(Scan
                    (AddPrimaryKeyColsToScanPrivate
                        (DuplicateScanPrivate $scanPrivate)
                    )
                )
                (MapFilterCols
                    (ReplaceFiltersItem
                        $filters
                        $itemToReplace
                        $leftFilter
                    )
                    $outCols:(UnionCols
                        (OutputCols $input)
                        (PrimaryKeyCols
                            (TableIDFromScanPrivate $scanPrivate)
                        )
                    )
                    (OutputCols $leftScan)
                )
            )
            []
            (remapColSet
                $scanCols
                $outCols
                (OutputCols $leftScan)
            )
        )
        $rightProject:(Project
            (Select
                $rightScan:(Scan
                    (AddPrimaryKeyColsToScanPrivate
                        (DuplicateScanPrivate $scanPrivate)
                    )
                )
                (MapFilterCols
                    (ReplaceFiltersItem
                        $filters
                        $itemToReplace
                        $rightFilter
                    )
                    $outCols
                    (OutputCols $rightScan)
                )
            )
            []
            (remapColSet
                $scanCols
                $outCols
                (OutputCols $rightScan)
            )
        )
        (MakeSetPrivate
            (OutputCols $leftProject)
            (OutputCols $rightProject)
            $scanCols
        )
    )
    $projections
    $passthrough
)
